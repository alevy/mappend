---
title: 'Multi-domain and multi-user specification'
date: Nov. 16th 2015
---

# Requirements

Each user should be tied to one or more domains:

  1. An implicit "_\[username\]_.blogdomain.biz"

  2. Zero or more non-"\*.blogdomain.biz"

Users can hide "_\[username\]_.blogdomain.biz".

# Considerations

## How should these be stored in the database?

There are several options for organizing hostname --> user --> posts
associations in the database.

### Array of hostnames as column in `user` table

Each user's hostname is added to an array column in the user table.

For each HTTP request:

```sql
select post.* from post, user where ? @> user.hostnames
                              and post.title = ?
                              and user.id = post.user_id;
```

GIN indexes in PostgreSQL is supposed to make this not very expensive.

In addition, the user id can be cached in a hostname specific cookie, so the
selection is not required for each page view, only once per client session.

Adding hostnames is similarly simple (at least without considering uniqueness)

### Hostname Model table

Hostnames are PostgreSQL-ORM `Model`s, and each hostname in it's own row with a
"regular" integer, auto-increment primary key.

For each HTTP request:

```sql
select post.* from post, hostname where hostname.hostname = ? 
                              and post.title = ?
                              and hostname.user_id = post.user_id;
```

`hostname` is indexed via a secondary index. Since the `"hostname"` table
doesn't contain much data, so I'm not sure if there is an indirection from the
secondary table, or if the data is simply normalized.

Adding hostnames is a matter of inserting a new row (`id` is generated by
auto-increment by postgres):

```sql
insert into hostname (hostname, user_id) values(?, ?);
```

### Hostname join-table (hostname as primary key)

Hostnames are a regular join-table with the `hostname` as a the primary key.

Otherwise, ditto above.

## How is hostname uniqueness guaranteed?

### Array of hostnames as column in `user` table

A GIN index on an array column cannot have a uniqueness constraint on each of
the values in the array. Instead, the application must check uniqueness
explicitly, in a transaction.

```sql
begin transaction
update user hostnames = hostnames || ? where id = ?;
//TODO check if duplicates and, if so, rollback
end transaction
```

### Hostname table (both options)

Hostname uniqueness is guaranteeed, simply, by a unique index on the hostname
column. Inserting is vanilla:

```sql
insert into hostname (hostname, user_id) values (?, ?)
```

## How is hostname ownership verified (re-verified)?

We need to verify, not only, that the hostname points to our servers, but also
that the owner of the hostname intends it to be used for a specific blog (to
avoid a vonfused deputy attack).

For subdomains (www.mydomain.com, blog.mydomain.com) we can simply verify that
their DNS records have a CNAME that points to the user's implicit domain
([username].blogdomain.biz).

CNAME are not allowed for top-level domains, so instead, we can assume that a
top-level domain has an associated `www` sub-domain, and verify that sub-domain
using it's CNAME DNS record (as above).

## How is the implicit hostname stored?

The implicit hostname is always a subdomain of the our main domain:
[username].blogdomain.biz. We simply store the hostname implicitly as the user's
username. This just means we need separate logic to associate a hostname with a
user when the hostname is a subdomain of our domain.

